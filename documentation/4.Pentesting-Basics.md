# Shell Scripts

## Bash Shell Scripts

### Basics

A shell script is a plain-text file that contains a series of commands that are executed as if they had been typed at a terminal prompt and whose files usually end with .sh.

#### Shebang

Scripts begin with the 'shebang', a comment on the first line with an absolute path to the interpreter to be used to run the script.  This line is ignored by the interpreter.

```bash
# Regular old shebang
#!/bin/bash
# Or to display debug output:
#!/bin/bash -x
# Debug output will be shown inline with output, denoted by a + for code executed in the current shell and ++ for a subshell
```

Comments are preceded by a hashtag

```bash
# I am a comment
```

#### Execution

A user must have execute permissions on the script file in order to run it.  If the user is the owner of the file, generally the permission would be set to `chmod 700` to give only the owner access to execute.  You can also use `chmod +x script.sh`

When executing anything in bash, it must be referenced by path (relative or full) or be found in a directory included in the system path ($PATH).  Therefore, to run scripts in the current directory, precede it with `./` (as in `./script.sh`) so that Bash knows you intend to run the file in the current directory.  This design prevents users from accidentally running something in the current directory when they really intended to run a program that is in the system path elsewhere.

### Variables

Assigned with VARNAME=VALUE, with no spaces around the equal sign.  Variable values can contain spaces, but it must be enclosed in single or double-quotes first.  Variable names are case sensitive.

When setting a variable, you just use the name of the variable with no special character

```bash
# Example of setting a variable
variable=value
```

When you want to use the value that a variable contains (called referencing the value), you need to put a `$` in front of the variable name.  Whenever Bash sees a variable with a `$` in front of it, it will interpret it as the value instead.

```bash
# Example of referencing a variable's value
echo $variable
# This would output 'value' 
```

Beware of special reserved variables.  There are some variables that the system already has defined and these should not be used.  Almost all of them are all uppercase, so for this reason, it's better to use all lowercase when defining variables.

#### Special Variables

| Variable  | Description                                                  |
| --------- | ------------------------------------------------------------ |
| $0        | Refers to the Bash script name                               |
| $1 - $9   | Refers to the 1st, 2nd, etc. argument passed to the Bash Script (arguments are delimited by spaces) |
| $#        | Number of arguments passed to the Bash script                |
| $@        | All arguments passed to the Bash Script                      |
| $?        | Displays the exit status of the most recently run process    |
| $$        | The process ID of the current Bash Script                    |
| $USER     | The username of the user running the script                  |
| $HOSTNAME | The hostname of the machine                                  |
| $RANDOM   | Generates a random number                                    |
| $LINENO   | The current line number of the script                        |

### User Input

Display a prompt to the user and get input:

```bash
read -sp 'Prompt text: ' INPUT_VAR
# Options
-p	'Prompt Text: '	# Specify a prompt with given text
-s 					# Silent input (does not show input)
```

To add line breaks in the prompt:

```bash
read -rep $'Prompt text:\n' INPUT_VAR

#Words of the form $'string' are treated specially.  The word expands to  string, with backslash-escaped characters replaced as specified by  the  ANSI  C  standard.  Backslash escape sequences, if present, are decoded  as follows:

#- (...)
#- \n     new line
#- (...)

#The expanded result is single-quoted, as if the  dollar  sign  had  not  been present.
# A  double-quoted  string  preceded  by a dollar sign ($) will cause the  string to be translated according to the current locale.  If  the  cur-  rent  locale  is C or POSIX, the dollar sign is ignored.  If the string  is translated and replaced, the replacement is double-quoted.
```

### Control Structures

#### If Statements

Uses a very specific syntax, including required spaces.  The testing conditions are enclosed square brackets, which are actually a reference to the `test` command (see 'Test Syntax' section for testing options).  When building the test condition, refer to the `test` command's man page for the syntax within these square brackets.  Also be sure to include the spaces between the brackets and the conditions inside them.

```bash
# General format, NOTE the spaces in the brackets!
if [ <some test> ]
then
	<perform actions>
fi

# Technically correct, but harder to read
if test <some test>
then
	<perform an action>
fi

# Example
a=20
if [ $a -le 20 ]
then
	echo $a
fi
```

##### else statement

Provides an alternate branch if the test fails.   Notice there is no `then` statement that follows `else`.

```bash
# NOTE the spaces in the brackets!
if [ <some test> ]
then
	<do this if the test is true>
else
	<do this if the test is not true>
fi
```

##### elif statement

Provides multiple tests and multiple branches.  Notice `elif` is followed by a `then` statement.

```bash
# NOTE the spaces in the brackets!
if [ <some test> ]
then
	<do this if the 1st test is true>
elif [ <another test> ]
then
	<do this if the elif test is true>
else
	<do this if none of the tests are true>
fi 
```

#### Case statement

```bash
# Evaluates the value of the Expression/Variable and performs commands based on outcome
case $VARIABLE in

  PATTERN_1)
    STATEMENTS
    ;;

# You can do an OR statement with pipe for multiple matches
  PATTERN_2 | PATTERN_3)
    STATEMENTS
    ;;

  PATTERN_N)
    STATEMENTS
    ;;

  *)
    STATEMENTS
    ;;
esac

################ Example
read -p 'Guess a number between 1 and 5: ' number
case $number in

  1 | 5)
    echo -n "You're too cold"
    ;;

  2 | 4)
    echo -n "You're getting warmer"
    ;;

  3)
    echo -n "Three was the number!"
    ;;

  *)
    echo -n "That's not a number between 1 and 5"
    ;;
esac
```

#### Loops

##### For Loops

Performs an action for each item in a list.

```bash
# General Format
for VAR in <list>
do
	<action to perform>
done

# Example (with seq command substitution)
for IP in $(seq 1 10)
do
	echo 10.11.1.$IP
done

# Example as one-liner
for IP in $(seq 1 10); do echo 10.11.1.$IP; done
```

###### Brace Expansion

Also known as  Sequence Expression.  Used to quickly generate a list of items in a range.

NOTE:  If you use a variable in a brace expansion, it will evaluate the brace expansion before the variable, meaning `{1..$n}` will be seen as just a string because `$n` is a variable and not an integer when the brace expansion occurs.  

To use variables in a range, use the `seq` command as shown in the for loop examples.

```bash
# Example with digits
for i in {1..10}; do echo $i; done
# Output
1
2
<snip>
10

# Example with characters
for i in {a..z}; do echo $i; done
# Ouput
a
b
<snip>
y
z
```

##### While Loops

Executes code while an expression is true.

Note:  Look out for 'off-by-one' errors due to incrementing or not incrementing a counter in an expected way.  Always test your script to make sure your results include the intended range.

```bash
# General Format
while [ <some test> ]
do
	<action to perform>
done

# Example - Print IP's from 1 to 10
counter=1
while [ $counter -le 10 ]
do
	echo "10.11.1.$counter"
	((counter++))
done
```

Practical Examples:

```bash
# Loop through a file and perform a command on each line
while read -r LINE; do nc -nv $LINE 110; done < hosts
```

#### Test Syntax

As stated, the square brackets `[ ]` are actually an alias to the `test` command.  Be sure to observe the following:

- Always make sure to leave spaces around the square brackets and the text.
- When expressing strings, be sure to put them in quotes and prepend it with an `$`, as in `"$STRING"`.  
- Integers do not need quotes.

Below are common options that can be used within the test command's brackets:

| Operator                     | Description:  Expression True if...                     |
| ---------------------------- | ------------------------------------------------------- |
| [ ! EXPRESSION ]             | The EXPRESSION is false. (Note the space after the `!`) |
| [ "$STRING1" != "$STRING2" ] | STRING1 is not equal to STRING2                         |
| [ "$STRING1" == "$STRING2" ] | STRING1 is equal to STRING2                             |
| [ INTEGER1 -eq INTEGER2 ]    | INTEGER1 is equal to INTEGER2                           |
| [ INTEGER1 -ne INTEGER2 ]    | INTEGER1 is not equal to INTEGER2                       |
| [ INTEGER1 -gt INTEGER2 ]    | INTEGER1 is greater than INTEGER2                       |
| [ INTEGER1 -lt INTEGER2 ]    | INTEGER1 is less than INTEGER2                          |
| [ INTEGER1 -ge INTEGER2 ]    | INTEGER1 is greater than or equal to INTEGER 2          |
| [ INTEGER1 -le INTEGER2 ]    | INTEGER1 is less than or equal to INTEGER 2             |

## PowerShell Scripts

While we will not construct PowerShell scripts in this class, you should be familiar with reading them and their structures as you will be using prebuilt ones.

### Execution Policies

Controls what can load or run on the system.

- 'restricted' (Default) - system will neither load PS config files or run PS scripts

- 'unrestricted' - allows loading and running anything

```powershell
# Checks the current policy
Get-ExecutionPolicy
# Checks the current policy for the Current User
Get-ExecutionPolicy -scope currentuser
```

If it doesn't show 'Unrestricted', this will stop the script from running.  There are different ways to fix this:

1. Modify the policy for the system (Requires Admin)

   ```powershell
   # Sets the current policy (requires admin prompt)
   Set-ExecutionPolicy Unrestricted -force
   ```

2. Modify the policy for the user:

   ```powershell
   Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser -force
   ```

3. Bypass the policy per script

   ```powershell
   # This is run from PowerShell, not Command Prompt
   powershell -ExecutionPolicy Bypass -File .\script.ps1
   ```

More ways:  https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/

### Comparison Operators

Comparison operators are in the form of 

```powershell
( L.VALUE OPERATOR R.VALUE)
```

| Operator | Description                                                  |
| -------- | ------------------------------------------------------------ |
| -eq      | equals                                                       |
| -ne      | not equal                                                    |
| -gt, -ge | greater than, greater than or equal to                       |
| -lt, -le | less than, less than or equal to                             |
| -like    | wildcard match.  <br />? matches a single character, * matches any numer of characters |
| -match   | Regular expression match                                     |

### If Statements

```powershell
# Example
$x = 30

if($x -le 20){
   write-host("This is if statement")
}else {
   write-host("This is else statement")
}
```

### Loops

#### Foreach

```powershell
Foreach($obj in $Result)
{
	Foreach($prop in $obj.Properties)
	{
		$prop
	}
	
	Write-Host "-------------------------"
}
```

# Network Scanning

## NetDiscover

This tool will passively monitor ARP responses in the layer 2 broadcast domain and record the IP and MAC addresses.   This is effective at finding hosts with firewalls or ones that block pings.

```bash
# auto scan, passive scanning
sudo netdiscover
```

It can also actively scan by generating forged ARP requests to all IPs in a range.  These forged ARP requests will appear to originate from the IP address `x.x.x.67`, based on the network range it was given, regardless of the IP actually making the requests.

```bash
# Scan network range
sudo netdiscover -r 192.168.1.0/24
```

## nmap - Network Map Tool

Scans are in the format of:

```bash
nmap [OPTIONS] -p [PORT(S)] [TARGETS] -o[OUTPUT OPTIONS]
```

### Host Discovery

Hosts are specified in one of the following formats:

| Syntax      | Meaning              |
| ----------- | -------------------- |
| 1.1.1.1     | Scan a single IP     |
| 1.1.1.0/24  | Scan a network       |
| 1.1.1.1-100 | Scan a range of IP's |

More host discovery options are available as well:

| Option   | Discovery Type                                               |
| -------- | ------------------------------------------------------------ |
| -Pn      | Treat every host as online, skipping host discovery (good if the host is blocking pings) |
| -iL FILE | Scan hosts listed in FILE                                    |
| -n       | Disable name resolution                                      |

### Port Syntax

| Syntax        | Meaning                                                      |
| ------------- | ------------------------------------------------------------ |
| -p (or -p-)   | Scan all ports 0 to 65535                                    |
| -p80          | Scan one port (80)                                           |
| -p1-10        | Scan a range of ports                                        |
| -p1,3,5,7     | Scan a set of ports.                                         |
| --top-ports=X | Scan the X top most common ports in /usr/share/nmap/nmap-services |

The range and set of ports can be combined by inserting the range as one of the members of the set.

### Port Scan Options

By default, nmap scans the 1000 most popular ports and uses a Stealth (SYN) scan, unless nmap does not have raw socket privileges, at which point it defaults to the TCP Connect scan.

These flags are supplied to nmap to tell it what kind of scan to perform.  Flags can be combined as well to do more than one type of scan.

| Option | Scan Type                                                    |
| ------ | ------------------------------------------------------------ |
| -sT    | TCP Connect Scan - performs full 3-way handshake             |
| -sS    | TCP SYN Scan - sends a SYN and looks for SYN-ACK, then resets |
| -sU    | UDP Scan - looks for ICMP unreachable response, but also sends port-specific packets to well-known ports to check for respones |
| -sn    | Network Sweep - Performs light reconnaissance using ping scans and a few other probes to find available hosts without doing port scans. |
| -sV    | Service/Version Info - Probes ports & determines what the service & version are.  OSCP calls this Banner Grabbing |

### Other Scan Options

| Option | Description                                                  |
| ------ | ------------------------------------------------------------ |
| -A     | Aggressive scan - Enable OS detection, version detection, script scanning, and traceroute |
| -O     | Enable OS Detection                                          |
| -sC    | Runs the 'default' category of scripts against the target    |

### Nmap Scripting Engine (NSE)

Launch user-created scripts to automate different scanning tasks.  These can range from DNS enumeration, brute force attacks, to vulnerability identification.

Scripts are located in the `/usr/share/nmap/scripts/` folder on Linux and are launched with `--script SCRIPTNAME` or `--script=SCRIPTNAME`, or you can even run multiple scripts using wildcard matches such as `--script=ABC*` to run any scripts stating with `ABC`.

Some example scripts listed below:

| Script Name       | Function                                         |
| ----------------- | ------------------------------------------------ |
| smb-os-discovery  | Attempts to connect to SMB server & determine OS |
| dns-zone-transfer | Attempts a DNS zone transfer                     |

To display more info about a script, use the `--script-help=SCRIPTNAME` option instead.

### Output Files

Output files provide advantages over using stdout, including the ability to easily grep through the output or to feed the output to other sources such as Dradis.

| Option       | Effect                                                       |
| ------------ | ------------------------------------------------------------ |
| -oG FILENAME | Creates a Greppable output file                              |
| -oX FILENAME | Creates an XML format file                                   |
| -oN FILENAME | Output a 'normal' format file                                |
| -aA BASENAME | Output in the three major formats at once, using the base filename |

### Examples

Scan all ports of a host

```bash
nmap -p 10.11.1.220
```

Scan all ports on a range of IP's

```bash
nmap -p 10.11.1.220-240
```

Scan all ports of a host, perform version scanning with 2x verbosity, show only open ports and the reason for the port's state.

```bash
sudo nmap 192.168.216.44 -p- -sV -vv --open --reason
```

Aggressive scan of network, one port, only show open results & store to file

```bash
sudo nmap -A -p80 --open 10.11.1.0/24 -oG namp-scan_10.11.1.1-254


# Options
-A		# Aggressive Scan
-p80	# Scan port 80
--open	# Only return machines with open ports
-oG file	# Output to file in Grepable format
```

# File Transfers

## HTTP

In Kali Linux, you can start up quick HTTP server in the current directory that can be access from a webbrowser or HTTP download commands:

```python
### Python2
sudo python2 -m SimpleHTTPServer 80
### Python3
sudo python3 -m http.server 80

-m	# Specify by module
80	# Port to listen on, can be any port
```

Files can be downloaded from HTTP in the CLI as well:

<u>Linux</u>

```bash
# Download a file at URL and name it FILENAME
wget -O OUTFILE URL

# Download a file from an HTTPS site and avoid certificate errors
wget -q --no-check-certificate URL -O OUTFILE
# Options
-O	# Specify filename to save as
-q	# quiet mode, turn off wget's output
--no-check-certificate	# "Insecure HTTPS" - Don't check the server cert against available certificate authorities and don't require the URL hostname to match the common name presented by the cert.  Only use this on trusted sites.

#### Example: Download file to current folder
wget http://domain.com/file.txt

#### Example: Download file to home folder
wget -O ~/outfile.txt http://domain.com/file.txt
```

<u>Windows PowerShell</u>

PowerShell commands can be run from a command prompt by preceding the command with `powershell -c` and enclosing the command in double-quotes `" "`.  

```powershell
(New-Object System.Net.WebClient).DownloadFile('http://SERVER_IP/SRC_FILE','LOCALPATH\DST_FILE')

# Examples:
# From Command Prompt
# Downloads file.exe from webserver at 10.250.226.250 and saves the file as c:\temp\file.exe
powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://10.250.226.250/file.exe','c:\temp\file.exe')"

# Same thing but run directly from PowerShell
(New-Object System.Net.WebClient).DownloadFile('http://10.250.226.250/file.exe','c:\temp\file.exe')
```

## Netcat

Netcat sometimes comes as the command `netcat` or just `nc`.  The options are the same whether it is run on Windows or Linux.

**<u>WARNING</u>**:  When transferring files with netcat, the transfer will often freeze at the end and won't notify you it's complete.  You can cancel it with `CTRL+C` and check the file sizes on both ends to tell if it was successful.  For files under 10MB, it should take less than a minute for sure.

```bash
netcat [OPTIONS] host [REMOTE_PORT]

## Examples
# Server end
# Note that listening requires admin privileges
sudo nc -nvlp 8100 < file-to-send

# Client end
nc -nv 10.250.226.250 8100 > file-to-save

# Options
-n		# Numeric-only IP's
-v		# Verbose output, use twice for more verbose
-l		# listen (Server mode)
-p		# Used with -l to specify port
```

## SMB

You can spin up a quick SMB server on Kali Linux using Impacket's SMB Server.  You can connect to this from other servers and upload or download files, or even execute files (like exploits!):

<u>Start Server on Linux</u>

```bash
sudo impacket-smbserver SHARENAME LOCALFOLDER

#### Examples
# Start SMB Server from the current directory
sudo impacket-smbserver kalishare ./

#SMB Version 2 Support
sudo impacket-smbserver kalishare ./ -smb2support

#### Options
kalishare # sharename
./	# share mount point in local filesystem
```

<u>Connect to share from Windows</u>

```powershell
# List dir
dir \\10.250.226.250\kalishare
# Get file
copy \\10.250.226.250\kalishare\file.exe .
# Execute file directly from the share
\\10.250.226.250\kalishare\file.exe
```

## FTP Scripting

If you are connect to a remote machine and don't have an interactive prompt, you can still use FTP if you create a script file and run it:

```powershell
####Example
# Create local folder and switch to it
mkdir c:\temp
cd c:\temp
# Build the script file in ftp.txt
echo open 10.250.226.250 21> ftp.txt
echo USER admin>> ftp.txt
echo mypassword>> ftp.txt
# Passive mode helps get by firewalls blocking port 20
echo passive >> ftp.txt
# Need to switch to Binary for transfers
echo bin >> ftp.txt
# Tell the client to get files
echo GET file.exe >> ftp.txt
echo bye >> ftp.txt

# Run the script file
ftp -v -n -s:ftp.txt
```

